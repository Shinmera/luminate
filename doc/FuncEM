 ______                ______ __  __ 
|  ____|              |  ____|  \/  |
| |__ _   _ _ __   ___| |__  | \  / |
|  __| | | | '_ \ / __|  __| | |\/| |
| |  | |_| | | | | (__| |____| |  | |
|_|   \__,_|_| |_|\___|______|_|  |_|
=--  Functional Extensive Markup  --=

 __   __  __          ___    __      
|  \ |_  |_  | |\ | |  |  | /  \ |\ | 
|__/ |__ |   | | \| |  |  | \__/ | \| 
                             
Generally a tag is marked like so:

  tag{ text to be marked }

If the tag requires additional arguments, they are specified like so:

  tag(args1,args2){ text to be marked }

For single word markup, syntactical sugar can be used:

  #tText

To escape text from being marked, use the special nomarkup tag:

  !{ this won't be marked }!

There's also a sugar equivalent:

  #!NoParse


 __        __   __         __  
|__)  /\  |__) (_  | |\ | / _  
|    /--\ | \  __) | | \| \__) 

Parsing has to happen according to XML markup, so a simple regex won't do.
EG:

  bold{ italic{ lol } }

Has to produce:

  <strong> <em> lol </em> </strong>

And not as regex would imply:

  <strong> <em> lol </strong> </em>

Sugar markup can be parsed quickly with regex though.
Any noparse blocks will be ignored through a simple flag as the loop iterates over the text.
Once it hits a }!, it'll reset the flag and continue on parsing as usual.
Any kind of balance issues with the tags have to be cleared in advance by simply filling up the required amount of tags.
The user's original intent is lost in this, but we don't really have to care since it's impossible to correctly guess the closing position.
To get the correct order of opening/closing tags, a simple stack will do.
Internally, the resulting tag forms get used with @@ annotations for the body and $$ annotations for arguments.
Optionally the annotations can contain an indicator for the type of value allowed.
