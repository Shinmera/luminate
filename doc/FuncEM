 ______                ______ __  __ 
|  ____|              |  ____|  \/  |
| |__ _   _ _ __   ___| |__  | \  / |
|  __| | | | '_ \ / __|  __| | |\/| |
| |  | |_| | | | | (__| |____| |  | |
|_|   \__,_|_| |_|\___|______|_|  |_|
=--  Functional Extensive Markup  --=
=--   Specification Version 1.3   --=

 __   __  __          ___    __      
|  \ |_  |_  | |\ | |  |  | /  \ |\ | 
|__/ |__ |   | | \| |  |  | \__/ | \| 
                             
FuncEM Markup - The way the user inputs FuncEM markup.
Generally a tag is marked like so:

  tag{ text to be marked }

If the tag requires additional arguments, they are specified like so:

  tag(args1,args2){ text to be marked }

Arguments can either be specified in the sequence that they are required by the function or through keys (Since v1.2):

  tag(:key1 args1,:key2 args2){ text to be marked }

For single word markup, syntactical sugar can be used:

  t#Text

To escape text from being marked, use the special nomarkup tag:

  !{ this won't be marked }!

There's also a sugar equivalent:

  !#NoParse

The deftag structure allows you to build your own tags inside the document (Since v1.3).
It takes the tag name and a rest body of argument placeholders as arguments.

  deftag(name,argument1placeholder,argument2placeholder){ Tag instructions }

Further language constructs available to build tags are only active inside deftag bodies.

 tag(tag,class,style,extra){content}
 div(class,style,extra){content} 
 echo{string} 
 print{var}                                 (since 3.1)
 set(var){value} 
 get{var} 
 if(val1,val2,op){instructions} 
 loop(from,to,stepsize){instructions}       (since 3.1)
 replace(search,replace){content}           (since 3.15)

Recursion is NOT supported. The variable holding the loop counter is called loop.
Available OPs for IF are: ==, !=, <, >, <=, >=, like, !like. The latter two are for string nocase comparison.

Argument placeholders are structured by NAME TYPE DEFAULT. Name and type cannot contain spaces.
The following types are available:

 TEXT  : Same as specifying no type at all. Any kind of character sequence is allowed.
 STRI  : An alphanumerical string.
 URLS  : Any kind of string that passes the PHP URL filter.
 MAIL  : Any kind of string that passes the PHP MAIL filter.
 DATE  : Any kind of string that passes the Toolkit DATE validity check.
 INTE  : Numerical value.
 INTEx : A number smaller or equal to x.
 BOOL  : A boolean (1,0,true,false) (since 1.35)

The HTML end-result is called FuncEM Code.
This code can contain argument placeholders, denoted by $$.
The start and end tags are separated by a @ .
F.e. a simple url:

  url(link URLS [,title TEXT [,target STRI _self]]){Text}
  <a href="$link URLS$" title="$title TEXT $" target="$target STRI _self$" >@</a>

Another example, for an image tag:

  img([alt STRI [,title TEXT [,class TEXT]]]){ImageUrl}
  <img alt="$alt STRI image$" title="$title TEXT$" class="$class TEXT$" src="@" />

This allows for a very advanced tagging system.

 __        __   __         __  
|__)  /\  |__) (_  | |\ | / _  
|    /--\ | \  __) | | \| \__) 

Parsing has to happen according to XML markup, so a simple regex won't do.
EG:

  bold{ italic{ lol } }

Has to produce:

  <strong> <em> lol </em> </strong>

And not as regex would imply:

  <strong> <em> lol </strong> </em>

Sugar markup can be parsed quickly with regex though.
Any noparse blocks will be ignored through a simple flag as the loop iterates over the text.
Once it hits a }!, it'll reset the flag and continue on parsing as usual.
Any kind of balance issues with the tags have to be cleared in advance by simply filling up the required amount of tags.
The user's original intent is lost in this, but we don't really have to care since it's impossible to correctly guess the closing position.
To get the correct order of opening/closing tags, a simple stack will do.

A separate function handles the parsing of the FuncEMCode itself. 
If the arguments requirement isn't met, the FEM tag is filled back in without parsing.

--Since 1.3:
Any kind of tag, be it functional or regular gets its own lambda function that the parser invokes.
deftag blocks get read in as a pre-compile phase and the resulting tag function is saved in the tag array.
Regular functions saved in the database get translated upon load.